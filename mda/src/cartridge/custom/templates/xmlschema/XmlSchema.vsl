<?xml version="1.0" encoding="$xmlEncoding"?>
<!-- 
    Attention: Generated code! Do not modify by hand!
    Generated by: XmlSchema.vsl (cartridge for FuGE version 1) 
         
  -->
<xsd:schema 
    targetNamespace="http://fuge.sourceforge.net/fuge/1.0"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
    xmlns:fuge="http://fuge.sourceforge.net/fuge/1.0"
    elementFormDefault="qualified">
#foreach ($type in $types)
#set ($typeName = "${type.fullyQualifiedName}Type")
  <xsd:complexType name="$typeName" abstract = "${type.abstract}">
     <xsd:annotation>
          <xsd:documentation>${type.getDocumentation("").replaceAll("\n"," ").replaceAll("<p>","").replaceAll("</p>","")}</xsd:documentation>
		 </xsd:annotation>
#if ($type.generalization) 
    <xsd:complexContent>
     <xsd:extension base="fuge:${type.generalization.fullyQualifiedName}Type">
#end

   <xsd:sequence>

#if ($type.associationEnds)
#foreach ($associationEnd in $type.associationEnds) 
#set ($otherEnd = $associationEnd.otherEnd)
#if ($otherEnd.navigable && ($otherEnd.type.isEnumeration()==false) && ($otherEnd.hasExactStereotype("AbstractAssociation") == false))

       #if($associationEnd.composition &&  ($otherEnd.hasExactStereotype("MapAssocToElement") == true) )##For these cases, the association name is required in the schema
       <xsd:element name="_${otherEnd.name}" minOccurs="${otherEnd.minOccurs}" maxOccurs="1">
         <xsd:annotation>
          <xsd:documentation>${otherEnd.association.getDocumentation("").replaceAll("\n"," ").replaceAll("<p>","").replaceAll("</p>","")}
          </xsd:documentation>
		 </xsd:annotation>
         <xsd:complexType>
          <xsd:sequence> 
           <xsd:element ref="fuge:${otherEnd.type.name}" minOccurs="1" maxOccurs="${otherEnd.maxOccurs}"/>
	         </xsd:sequence>
         </xsd:complexType>
        </xsd:element>
       #elseif($associationEnd.composition &&  ($otherEnd.hasExactStereotype("MapAssocToElement") ==false) )##For these cases, the association name is not required in the schema
       <xsd:element ref="fuge:${otherEnd.type.name}" minOccurs="${otherEnd.minOccurs}" maxOccurs="${otherEnd.maxOccurs}">
       	 <xsd:annotation>
           <xsd:documentation>${otherEnd.association.getDocumentation("").replaceAll("\n"," ").replaceAll("<p>","").replaceAll("</p>","")}</xsd:documentation>
		 </xsd:annotation>
       </xsd:element>
      #elseif(($associationEnd.composition==false) &&  ($otherEnd.hasExactStereotype("MapAssocToElement") ==true) )##This is for cases, for example where there are parallel assocaitions to the same object, or the association name is needed to qualify the referenced object
       <xsd:element name="_${otherEnd.name}" minOccurs="${otherEnd.minOccurs}" maxOccurs="${otherEnd.maxOccurs}"> 
         <xsd:annotation>
          <xsd:documentation>${otherEnd.association.getDocumentation("").replaceAll("\n"," ").replaceAll("<p>","").replaceAll("</p>","")}</xsd:documentation>
		 </xsd:annotation>
               <xsd:complexType>
        			<xsd:attribute name="${otherEnd.type.name}_ref" use="required" type="xsd:string"/>
        	   </xsd:complexType>
        </xsd:element>
       #elseif(($associationEnd.composition==false) && $otherEnd.isMany()==true)##Treat otherEnd = many in the same way as 
        <xsd:element name="_${otherEnd.name}" minOccurs="${otherEnd.minOccurs}" maxOccurs="${otherEnd.maxOccurs}"> 
         <xsd:annotation>
          <xsd:documentation>${otherEnd.association.getDocumentation("").replaceAll("\n"," ").replaceAll("<p>","").replaceAll("</p>","")}</xsd:documentation>
		 </xsd:annotation>
               <xsd:complexType>
        			<xsd:attribute name="${otherEnd.type.name}_ref" use="required" type="xsd:string"/>
        	   </xsd:complexType>
        </xsd:element>
#end            
#end
#end

##need to loop to create an element for class attributes not flagged with XmlAttribute
#foreach  ($attribute in $type.attributes)
#if ($attribute.hasExactStereotype("XmlAttribute")==false)
#if($attribute.type.fullyQualifiedName == "string[]")
	<xsd:element name="${attribute.name}">
		 <xsd:annotation>
          <xsd:documentation>${attribute.getDocumentation("").replaceAll("\n"," ").replaceAll("<p>","").replaceAll("</p>","")}</xsd:documentation>
		 </xsd:annotation>
		<xsd:simpleType>
			<xsd:list itemType="xsd:string"/>
		</xsd:simpleType>
	</xsd:element>
#else
    <xsd:element name="${attribute.name}" type="xsd:${attribute.type.fullyQualifiedName}" minOccurs="$attribute.minOccurs" maxOccurs="$attribute.maxOccurs">
    	 <xsd:annotation>
          <xsd:documentation>${attribute.getDocumentation("").replaceAll("\n"," ").replaceAll("<p>","").replaceAll("</p>","")}</xsd:documentation>
		 </xsd:annotation>
    </xsd:element>
#end
#end
#end

    </xsd:sequence> 

#end

#foreach  ($attribute in $type.attributes)
#if(!($attribute.name  == "id") && ($attribute.hasExactStereotype("XmlAttribute")==true))
#if($attribute.type.isEnumeration())
#if($attribute.required) ##use="require" is not correct...??
	<xsd:attribute name="${attribute.name}" use="required">
#else
	<xsd:attribute name="${attribute.name}">
#end	
		<xsd:simpleType>
			<xsd:restriction base="xsd:NMTOKEN">
			#set($enumValues = $attribute.type.getAttributes())
		#foreach($enum in $enumValues)
				<xsd:enumeration value="$enum.name"/>
		#end
			</xsd:restriction>
		</xsd:simpleType>
	</xsd:attribute>
#else
#if($attribute.required) 
    <xsd:attribute name="${attribute.name}" use="required" type="xsd:${attribute.type.fullyQualifiedName}">
#else
    <xsd:attribute name="${attribute.name}" type="xsd:${attribute.type.fullyQualifiedName}">
#end
     <xsd:annotation>
      <xsd:documentation>${attribute.getDocumentation("").replaceAll("\n"," ").replaceAll("<p>","").replaceAll("</p>","")}</xsd:documentation>
	 </xsd:annotation>
    </xsd:attribute>	 
#end
#end##end of if for attribute "id"

#end##end of for loop for all attributes

#foreach ($associationEnd in $type.associationEnds) ##Need to run this loop again to create an attribute for any association ends with one cardinality, 
#set ($otherEnd = $associationEnd.otherEnd)
   #if(($associationEnd.composition==false) && $otherEnd.isMany()==false && ($otherEnd.hasExactStereotype("AbstractAssociation") == false) &&  $otherEnd.navigable && ($otherEnd.hasExactStereotype("MapAssocToElement") == false))##This is for the case of a many end on the association end... in these cases we do the same as above...
   #if($otherEnd.minOccurs == "1")
    <xsd:attribute name="${otherEnd.type.name}_ref" use="required" type="xsd:string">  
  #else
    <xsd:attribute name="${otherEnd.type.name}_ref" type="xsd:string">
  #end
   <xsd:annotation>
      <xsd:documentation>${otherEnd.association.getDocumentation("").replaceAll("\n"," ").replaceAll("<p>","").replaceAll("</p>","")}</xsd:documentation>
	 </xsd:annotation>
    </xsd:attribute>	 
#end
#end

#if ($type.generalization) 
    </xsd:extension>
    </xsd:complexContent>
#end

  </xsd:complexType>

  
#end

#foreach ($element in $types)
#set ($typeName = "${element.fullyQualifiedName}Type")
#if ($element.generalization) 
 <xsd:element name="$element.name" type="fuge:$typeName" abstract="$element.abstract" substitutionGroup="fuge:${element.generalization.name}" />
#else
 <xsd:element name="$element.name" type="fuge:$typeName" abstract="$element.abstract" />
#end
#end

</xsd:schema>     
