##
## This version of the cartridge is based on FuGE v1 cartridge but it is intended to be used for extensions where FuGE is imported rather than included in the schema
## 1. Ensure that andromda.xml is setup to parse only the extension and not FuGE: 
##				 <modelPackages process="false">FuGE</modelPackages>
##				 <modelPackages process="true">GelML</modelPackages>
## 2. Set namespace property in andromda.xml e.g. <property name="namespace">http://www.psidev.info/gelml/1.0</property>
## 3. Alter the namespace defintion below (line 16) xmlns:gelml to the name of your namespace (this must be the root package name in UML in lower case)
##
<?xml version="1.0" encoding="$xmlEncoding"?>
<!-- 
    Attention: Generated code! Do not modify by hand!
    Generated by: XmlSchema.vsl (FuGE V1_extensions version) 
  -->
<xsd:schema 
    targetNamespace="$namespace"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
    xmlns:fuge="http://fuge.sourceforge.net/fuge/1.0"
     xmlns:gelml="$namespace"  ##alter gelml to the name of your namespace, this is the root of the package structure in UML
    elementFormDefault="qualified">
    
<xsd:import namespace="http://fuge.sourceforge.net/fuge/1.0" schemaLocation="http://fuge.sourceforge.net/dev/V1Final/FuGEv1.xsd"/>
##Uncomment for local FuGE
##<xsd:import namespace="http://fuge.sourceforge.net/fuge/1.0" schemaLocation="C:\WorkGeneral\FuGE-OM\Version1\SpecDoc\Version1-Final\FuGEv1.xsd"/>    

#foreach ($type in $types)
#set ($typeName = "${type.fullyQualifiedName}Type")
  <xsd:complexType name="$typeName" abstract = "${type.abstract}">
     <xsd:annotation>
          <xsd:documentation>${type.getDocumentation("").replaceAll("\n"," ").replaceAll("<p>","").replaceAll("</p>","")}</xsd:documentation>
		 </xsd:annotation>
#if ($type.generalization) 
    <xsd:complexContent>
#set($superName = $type.generalization.fullyQualifiedName) 
#set($sNamespace = $superName.substring(0,$superName.indexOf(".")).toLowerCase())
     <xsd:extension base="${sNamespace}:${type.generalization.fullyQualifiedName}Type">
#end
#set( $doSeq = true)
#if ($type.associationEnds)
#foreach ($associationEnd in $type.associationEnds) 
#set ($otherEnd = $associationEnd.otherEnd)
#if ($otherEnd.navigable && ($otherEnd.type.isEnumeration()==false) && ($otherEnd.hasExactStereotype("AbstractAssociation") == false))
  #if ($doSeq) 
   <xsd:sequence>
    #set ($doSeq = false)
  #end     
       #if($associationEnd.composition &&  ($otherEnd.hasExactStereotype("MapAssocToElement") == true) )##For these cases, the association name is required in the schema
       <xsd:element name="_${otherEnd.name}" minOccurs="${otherEnd.minOccurs}" maxOccurs="1">
         <xsd:annotation>
          <xsd:documentation>${otherEnd.association.getDocumentation("").replaceAll("\n"," ").replaceAll("<p>","").replaceAll("</p>","")}
          </xsd:documentation>
		 </xsd:annotation>
         <xsd:complexType>
          <xsd:sequence> 
#set($otherName = $otherEnd.type.fullyQualifiedName)
#set($oNamespace = $otherName.substring(0,$otherName.indexOf(".")).toLowerCase())
           <xsd:element ref="${oNamespace}:${otherEnd.type.name}" minOccurs="1" maxOccurs="${otherEnd.maxOccurs}"/>
	         </xsd:sequence>
         </xsd:complexType>
        </xsd:element>
       #elseif($associationEnd.composition &&  ($otherEnd.hasExactStereotype("MapAssocToElement") ==false) )##For these cases, the association name is not required in the schema
#set($otherName = $otherEnd.type.fullyQualifiedName)
#set($oNamespace = $otherName.substring(0,$otherName.indexOf(".")).toLowerCase())
      <xsd:element ref="${oNamespace}:${otherEnd.type.name}" minOccurs="${otherEnd.minOccurs}" maxOccurs="${otherEnd.maxOccurs}"/>
      #elseif(($associationEnd.composition==false) &&  ($otherEnd.hasExactStereotype("MapAssocToElement") ==true) )##This is for cases, for example where there are parallel assocaitions to the same object, or the association name is needed to qualify the referenced object
       <xsd:element name="_${otherEnd.name}" minOccurs="${otherEnd.minOccurs}" maxOccurs="${otherEnd.maxOccurs}"> ##made a change to this part to simply a reference to elements e.g. rather than <_genericProtocol><Protocol_ref identifier_ref = "XYZ"/> It is now <_genericProtocol GenericProtocol_ref = ""/>
         <xsd:annotation>
          <xsd:documentation>${otherEnd.association.getDocumentation("").replaceAll("\n"," ").replaceAll("<p>","").replaceAll("</p>","")}</xsd:documentation>
		 </xsd:annotation>
               <xsd:complexType>
        			<xsd:attribute name="${otherEnd.type.name}_ref" use="required" type="xsd:string"/>
        	   </xsd:complexType>
        </xsd:element>
       #elseif(($associationEnd.composition==false) && $otherEnd.isMany()==true)##This is for the case of a many end on the association end... in these cases we do the same as above...
        <xsd:element name="_${otherEnd.name}" minOccurs="${otherEnd.minOccurs}" maxOccurs="${otherEnd.maxOccurs}"> ##made a change to this part to simply a reference to elements e.g. rather than <_genericProtocol><Protocol_ref identifier_ref = "XYZ"/> It is now <_genericProtocol GenericProtocol_ref = ""/>
         <xsd:annotation>
          <xsd:documentation>${otherEnd.association.getDocumentation("").replaceAll("\n"," ").replaceAll("<p>","").replaceAll("</p>","")}</xsd:documentation>
		 </xsd:annotation>
               <xsd:complexType>
        			<xsd:attribute name="${otherEnd.type.name}_ref" use="required" type="xsd:string"/>
        	   </xsd:complexType>
        </xsd:element>
       #end            
#end
#end

#foreach  ($attribute in $type.attributes)
#if ($attribute.hasExactStereotype("XmlAttribute")==false)
#if($attribute.type.fullyQualifiedName == "string[]")
	<xsd:element name="${attribute.name}">
		 <xsd:annotation>
          <xsd:documentation>${attribute.getDocumentation("").replaceAll("\n"," ").replaceAll("<p>","").replaceAll("</p>","")}</xsd:documentation>
		 </xsd:annotation>
		<xsd:simpleType>
			<xsd:list itemType="xsd:string"/>
		</xsd:simpleType>
	</xsd:element>
#else
		<xsd:element name="${attribute.name}" type="xsd:${attribute.type.fullyQualifiedName}" minOccurs="$attribute.minOccurs" maxOccurs="$attribute.maxOccurs">
    	 <xsd:annotation>
          <xsd:documentation>${attribute.getDocumentation("").replaceAll("\n"," ").replaceAll("<p>","").replaceAll("</p>","")}</xsd:documentation>
		 </xsd:annotation>
		</xsd:element>
#end
#end
#end

#if (!$doSeq) 
    </xsd:sequence> 
#set ($doSeq = true)
#end
#end


#foreach  ($attribute in $type.attributes)
#if(!($attribute.name  == "id") && ($attribute.hasExactStereotype("XmlAttribute")==true))
#if($attribute.type.isEnumeration())
#if($attribute.required) ##use="require" is not correct...??
	<xsd:attribute name="${attribute.name}" use="required">
#else
	<xsd:attribute name="${attribute.name}">
#end	
		<xsd:simpleType>
			<xsd:restriction base="xsd:NMTOKEN">
			#set($enumValues = $attribute.type.getAttributes())
		#foreach($enum in $enumValues)
				<xsd:enumeration value="$enum.name"/>
		#end
			</xsd:restriction>
		</xsd:simpleType>
	</xsd:attribute>
#else
#if($attribute.required) 
    <xsd:attribute name="${attribute.name}" use="required" type="xsd:${attribute.type.fullyQualifiedName}">
#else
    <xsd:attribute name="${attribute.name}" type="xsd:${attribute.type.fullyQualifiedName}">
#end
     <xsd:annotation>
      <xsd:documentation>${attribute.getDocumentation("").replaceAll("\n"," ").replaceAll("<p>","").replaceAll("</p>","")}</xsd:documentation>
	 </xsd:annotation>
    </xsd:attribute>	 
#end
#end##end of if for attribute "id"

#end##end of for loop for all attributes


#foreach ($associationEnd in $type.associationEnds) ##Need to run this loop again to create an attribute for any association ends with one cardinality, 
#set ($otherEnd = $associationEnd.otherEnd)
   #if(($associationEnd.composition==false) && $otherEnd.isMany()==false && ($otherEnd.hasExactStereotype("AbstractAssociation") == false) &&  $otherEnd.navigable && ($otherEnd.hasExactStereotype("MapAssocToElement") == false))##This is for the case of a many end on the association end... in these cases we do the same as above...
   #if($otherEnd.minOccurs == "1")
    <xsd:attribute name="${otherEnd.type.name}_ref" use="required" type="xsd:string">  
  #else
    <xsd:attribute name="${otherEnd.type.name}_ref" type="xsd:string">
  #end
   <xsd:annotation>
      <xsd:documentation>${otherEnd.association.getDocumentation("").replaceAll("\n"," ").replaceAll("<p>","").replaceAll("</p>","")}</xsd:documentation>
	 </xsd:annotation>
    </xsd:attribute>	 
         #end

#end

#if ($type.generalization) 
    </xsd:extension>
    </xsd:complexContent>
#end
  </xsd:complexType>

  
#end


#foreach ($element in $types)
#set ($typeName = "${element.fullyQualifiedName}Type")
#set($elementName = $element.fullyQualifiedName)
#set($eNamespace = $elementName.substring(0,$elementName.indexOf(".")).toLowerCase())
#if ($element.generalization)
#set($superName = $element.generalization.fullyQualifiedName)
#set($sNamespace = $superName.substring(0,$superName.indexOf(".")).toLowerCase()) 
 <xsd:element name="$element.name" type="${eNamespace}:$typeName" abstract="$element.abstract" substitutionGroup="${sNamespace}:${element.generalization.name}" />
#else
 <xsd:element name="$element.name" type="${eNamespace}:$typeName" abstract="$element.abstract" />
#end
#end
</xsd:schema>     
